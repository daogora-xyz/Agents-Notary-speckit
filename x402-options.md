# x402 Payment Options: Browser + Mobile Support

## Summary

**Your workflow is absolutely supported** by the x402 protocol. The protocol is payment-method agnostic and only specifies:

1. Server sends 402 with `paymentRequirements` JSON
2. Client sends X-PAYMENT header with signed authorization
3. Server verifies and grants access

The protocol does NOT dictate HOW the user creates that X-PAYMENT header - which means your multi-option payment page is perfect.

---

## What x402 Protocol Supports

From the official x402 documentation, the protocol flow is:

```
Client → Request resource
Server → 402 Payment Required (JSON with payment details)
[User pays somehow - browser, mobile, programmatic]
Client → Retry with X-PAYMENT header
Server → 200 OK with resource
```

The "somehow" is **entirely up to you**. This is by design.

---

## Your Payment Page Flow

### 1. LLM Receives 402 Response

```json
{
  "error": "payment_required",
  "request_id": "req_abc123",
  "payment_link": "https://certify.ar4s.com/pay/req_abc123",
  "payment": {
    "x402_version": 1,
    "scheme": "exact",
    "network": "base",
    "maxAmountRequired": "30000",
    "asset": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    "payTo": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
    "nonce": "0x2a",
    "valid_until": 1730388900,
    "resource": "https://certify.ar4s.com/v1/certify",
    "description": "Certify ashley-barr_offerletter-contract--unsigned.pdf"
  }
}
```

### 2. LLM Passes Link to User

```
LLM → User: "I need payment to proceed. Please visit this link to pay:
https://certify.ar4s.com/pay/req_abc123

You can pay with your browser wallet (MetaMask) or scan a QR code with your mobile wallet."
```

### 3. User Clicks Link → Payment Page

The payment page at `/pay/req_abc123` displays **both options**:

---

## Option A: Browser Wallet (MetaMask)

**UI Component:**
```html
<div class="payment-option">
  <h3>Pay with Browser Wallet</h3>
  <button onclick="payWithMetaMask()" class="btn-primary">
    Pay $0.03 USDC with MetaMask
  </button>
</div>
```

**Flow:**
1. User clicks button
2. JavaScript triggers MetaMask extension
3. MetaMask prompts for EIP-3009 signature
4. User approves in MetaMask
5. JavaScript constructs X-PAYMENT header
6. JavaScript POSTs to `/v1/certify` with X-PAYMENT
7. Page redirects to success/certification proof page

**Implementation:**
```javascript
async function payWithMetaMask() {
  const provider = new ethers.providers.Web3Provider(window.ethereum);
  const signer = provider.getSigner();

  // EIP-3009 signature
  const domain = {
    name: "USD Coin",
    version: "2",
    chainId: 8453,
    verifyingContract: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
  };

  const types = {
    TransferWithAuthorization: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "value", type: "uint256" },
      { name: "validAfter", type: "uint256" },
      { name: "validBefore", type: "uint256" },
      { name: "nonce", type: "bytes32" }
    ]
  };

  const value = {
    from: await signer.getAddress(),
    to: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
    value: "30000",
    validAfter: "0",
    validBefore: "1730388900",
    nonce: "0x2a"
  };

  const signature = await signer._signTypedData(domain, types, value);

  // Construct X-PAYMENT header
  const paymentPayload = {
    authorization: value,
    signature: signature
  };

  // POST with payment
  const response = await fetch('/v1/certify', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-PAYMENT': btoa(JSON.stringify(paymentPayload))
    },
    body: JSON.stringify({ request_id: 'req_abc123' })
  });

  if (response.ok) {
    window.location.href = '/success/req_abc123';
  }
}
```

---

## Option B: Mobile QR Code

**UI Component:**
```html
<div class="payment-option">
  <h3>Pay with Mobile Wallet</h3>
  <p>Scan this QR code with your mobile wallet:</p>
  <div id="qr-code">
    <!-- QR code image rendered here -->
    <!-- Generated by qr-code-mcp-server -->
  </div>
  <p class="help-text">
    Compatible with: MetaMask Mobile, Rainbow, Coinbase Wallet
  </p>
</div>
```

**QR Code Content (EIP-681 Format):**
```
ethereum:0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913@8453/transfer?
  address=0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb&
  uint256=30000&
  callback=https://certify.ar4s.com/v1/pay/req_abc123
```

**Flow:**
1. Page calls `qr-code-mcp-server.encode_x402_to_qr` → gets EIP-681 URI
2. Page calls `qr-code-mcp-server.generate_qr_image` → gets PNG/SVG
3. User scans QR with mobile wallet
4. Wallet parses EIP-681 URI
5. Wallet pre-fills USDC transfer transaction
6. User approves in wallet
7. **Wallet POSTs to callback URL** with X-PAYMENT header
8. Server processes payment and certifies data
9. User's browser page polls `/v1/status/req_abc123` and shows success

---

## The Missing Piece: Callback Endpoint

The x402 protocol doesn't explicitly define the callback flow, but it's trivial to add:

**New Endpoint:**
```
POST /v1/pay/:request_id
Headers:
  X-PAYMENT: <base64_encoded_payment_authorization>

Response:
  200 OK (same as successful /v1/certify response)
  {
    "request_id": "req_abc123",
    "status": "completed",
    "payment": { ... },
    "certification": { ... }
  }
```

**Internally, this endpoint:**
1. Extracts `request_id` from URL
2. Decodes X-PAYMENT header
3. Calls `x402-mcp.verify_payment`
4. Calls `x402-mcp.settle_payment`
5. Calls `circular-mcp` certification workflow
6. Returns certification proof

**This is identical to the retry logic in POST /v1/certify**, just a cleaner URL for mobile wallet callbacks.

---

## Page Polling for Mobile Flow

Since the mobile wallet makes a server-to-server callback, the user's browser needs to know when payment completes:

**JavaScript on Payment Page:**
```javascript
// Start polling when QR code is displayed
function pollPaymentStatus(requestId) {
  const interval = setInterval(async () => {
    const response = await fetch(`/v1/status/${requestId}`);
    const data = await response.json();

    if (data.status === 'completed') {
      clearInterval(interval);
      window.location.href = `/success/${requestId}`;
    } else if (data.status === 'failed') {
      clearInterval(interval);
      showError(data.error);
    }
  }, 2000); // Poll every 2 seconds
}
```

---

## Architecture Compatibility Check

✅ **x402 protocol** - Supports custom payment UIs (protocol is method-agnostic)

✅ **Payment page** - Can offer multiple payment methods

✅ **Browser wallet** - Direct MetaMask/Coinbase Wallet integration via EIP-3009

✅ **QR code** - EIP-681 format (already in your spec via `qr-code-mcp-server`)

✅ **Mobile wallet** - Callbacks to your server with X-PAYMENT header

✅ **Unified backend** - Both payment paths use same verification/settlement flow

---

## Implementation Summary

**What you need to add:**

1. **Payment page** at `/pay/:request_id`
   - Displays both browser and mobile options
   - Uses `x402-mcp.generate_browser_link` for MetaMask button
   - Uses `qr-code-mcp.encode_x402_to_qr` + `generate_qr_image` for QR

2. **Callback endpoint** at `/v1/pay/:request_id`
   - Accepts POST with X-PAYMENT header
   - Reuses existing verification/settlement/certification logic

3. **Status polling** on payment page
   - JavaScript polls `/v1/status/:request_id`
   - Redirects to success when completed

**What you already have:**

- ✅ All 4 MCP servers with required tools
- ✅ Payment verification logic (x402-mcp.verify_payment)
- ✅ Payment settlement logic (x402-mcp.settle_payment)
- ✅ QR code generation (qr-code-mcp-server)
- ✅ Certification workflow (circular-mcp-server)

---

## Conclusion

Your architecture **fully supports** the payment page with both browser and mobile options. The x402 protocol is intentionally flexible about payment methods, and your MCP server architecture already has all the necessary tools.

The only additions are:
1. A simple HTML payment page
2. A callback endpoint (trivial - reuses existing logic)
3. Status polling JavaScript

This gives users maximum flexibility: programmable agents can pay directly, browser users can use MetaMask, and mobile users can scan QR codes - all converging on the same x402 payment verification flow.
